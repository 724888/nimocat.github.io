---
layout: post
title: '区块链知识指南'
subtitle: '收录区块链中常见概念及解答'
date: 2018-02-20ß
categories: 技术
cover: 'http://p3sactqby.bkt.clouddn.com/18-3-9/89183419.jpg'
tags: 区块链 指南
---

# 区块链知识指南

## 文档类

1. [什么是背书](https://baijiahao.baidu.com/s?id=1587380849611281727&wfr=spider&for=pc)
2. [Hyperledger Fabric的单链多通道实现](http://blog.sina.com.cn/s/blog_16b6c12010102wjjs.html)
3. [什么是chaincode](https://www.cnblogs.com/zeyaries/p/7158027.html)
4. [Go并发编程](https://studygolang.com/articles/6012)
5. [Hyperledger fabric文档](http://blog.csdn.net/hejjiiee/article/details/53356206)
6. [智能预言机](http://www.8btc.com/smart-oralcle-codius)
7. [以太坊源码学习](http://www.cnblogs.com/baizx/p/6928622.html)


## 理解

<!--2018/3/8-->

#### ERC20与ERC721

ERC20和ERC721都是token标准的一种，由ETH发布，可以理解为1.一种接口标准 2.一种实现标准 3.大家自然遵守的开发标准。ERC20规定了同质token的接口标准，ERC721规定了非同质token的接口标准，这些标准通过部署到区块链网络后，在EVM上运行，每次调用需要缴纳gas（所有智能合约的运行都需要gas来支撑，为了避免死循环的出现，**一旦gas不足，所有数据立刻回滚**，此次交易无效）。智能合约通过一个发起人的地址进行部署，若直接向合约地址转账，无法触发任何事件，合约也不会运行代码，石沉海底，钱就打水漂了。但是通过钱包等App调用的时候，可以通过web3.js等接口调用合约中函数，这才是正确的转账或者说调用合约的正确方式。

#### 同质与非同质

*同质货币*：钱、黄金、银子（一般不具有收藏价值且不同token之间无差别）

*非同质货币*：以太猫、瓷器、陶器（具有收藏价值且唯一的等价物，不存在相同的token）

由于非同质货币的特殊性，每个NFT都需要单独监控去向。

<!--2018/3/9-->

#### 以太坊与智能合约

**打包过程：**每个矿工收到tx后，如果有代码则

**全节点与轻节点：**因为每个区块的MT仅仅是验证数据完整性的。所以非矿工下载区块头即可验证数据完整性，矿工则需要下载全节点。

**以太坊智能合约**最好是用来执行最简单的任务，比如运行一个简单的业务逻辑或者验证签名和其他密码对象，而不是用于复杂的操作，比如文件存储，电子邮件，或机器学习，这些会给网络造成压力。施加费用防止用户使网络超负荷。

一个重要需要注意的事情是内部交易或者消息不包含gasLimit。因为gas limit是由原始交易的外部创建者决定的（也就是外部拥有账户）。外部拥有账户设置的gas limit必须要高到足够将交易完成，包括由于此交易而长生的任何”子执行”，例如合约到合约的消息。如果，在一个交易或者信息链中，其中一个消息执行使gas已不足，那么这个消息的执行会被还原，包括任何被此执行触发的子消息。不过，父执行没必要被还原。//*也就是说，**合约**调用**合约**也需要gas，且合约之间属于**链内部**，所以合约之间的消息属于**内部消息**。*

**比特币与以太坊的区别：** **比特币**交易基于UTXO，属于无状态FTs转移，**以太坊**基于Account发布tx进行链上和链间通信，每次通信消耗gas支付给打包矿工。每次出块速度增加，Uncle Block的概率大大增加，uncle block奖励为打包奖励的1/32。

**为什么会有POW的思考：**如果没有了POW，任何人都可以接受交易并且打包交易，把块广播出去，这会造成极大数量的分叉，每个人都无法证明自己是诚实的，引入一种工作量机制后，如果你是诚实的，那么你就愿意花费一些代价来证明。再深入一些：POW生效的假设建立在：attacker权限极大。我们如果把attacker的level设置的特别高，那么相应证明自己的工作量也需要更大一些才能阻止作恶节点。**所以***共识机制的根本目的是为了让作恶产生成本。*

**思考——不基于代币的共识机制**：POW为了提高作恶成本，DPOS为了降低作恶可能，但本质上都离不开算力或代币证明。

### Q&A

1. 智能合约存储在哪？会被打包进区块吗？
答：会，因为每个contract会有contract address，contract address内的code address就是区块地址，每个单机上都会有一份合约副本。
2. Token contract 和智能合约的关系？
答：Token contract 是一种特殊的智能合约，里面定义了一种token，可以通过这个合约进行发币、ICO。
3. 广播到网络中的tx是否会消失？如果因为attacker把这部分网络down掉，tx没有发出去，是不是所有矿工无法接收到这个tx了，也就没法打包了。
答：是的，但是损失一个tx没啥关系，因为只有矿工消耗gas来打包之后，tx才会生效，如果tx没有广播出去，再次发送一次就好了，只要tx到一个矿工手里，就会变成一个块存储下来。
4. 为什么矿工需要下载全节点来获得所有的交易细节？
5. tx中的nonce、v,r,s都是什么？
答：区块的难度影响nonce，它是在挖矿时必须要使用proof-of-work算法来计算的一个hash值。
区块难度和nonce之间的关系用数学形式表达就是：
![p24](http://cdn.8btc.com/wp-content/uploads/2017/10/201710110607237530.png)

1. ## 我自己的笔记

**特性：**高级语言、类javascript+golang、支持ES6（不完全）的编译型语言

占空间大传引用，占空间小传值。大空间：字节数组、数组、字符串、结构体。

合约地址（uint160）是合约的指针，所以可以`mapping（address => String（匹配：建行合约#1030））`起到助记作用。

有`payable` 可以发value和使用`msg.value`，无`payable`不可以，所以重点在于**合约的函数具不具有处理转账的功能**，合约内功能的最小粒度为`function`。

ABI协议：contract => 二进制文件 => 二进制文件分割法则 => 以此定义接口。

<!--想法：竞技类区块链游戏（BRPG）开发，链上游戏，获得代币，良性循环，无充值游戏，让线上货币与线下货币进行交互，竞技激励模式（竞技游戏本身具有娱乐性，与养成类代币游戏严格区分，把游戏中的金币变成代币，玩家本身察觉不到，但是再在底层已经上链，游戏内货币具有价格波动，既具有投资价值也具有娱乐价值），甚至可以把contract概念变成套餐概念（一种玩家的投资）-->

不能对引用类型赋值：eg：

```go
uint[] y = x;
delete x;//OK 复写，类似磁盘强力删除(数据区域赋空白值)
delete y;//不行，y本身就是一个x的引用，因为数组类型在storage中，对他人引用赋值报错。
```

**数制转换**：低位转高位：OK；高位转低位：高位被截断

`selfdestruct(address recipt)`：跑路按钮，撕掉合约拿钱跑路。

需要注意的是，在合约的构造器中，不能使用`this`调用函数，因为当前合约还没有创建完成。

表达式执行顺序和java类似，不固定执行顺序，但保证调用栈是稳定的。

如果你通过消息调用一个函数，但在调用的过程中，并没有正确结束(gas不足，没有匹配到对应的函数，或他自己出现异常)。底层操作如`call`,`send`,`delegatecall`或`callcode`除外，它们不会抛出异常，但它们会通过返回`false`来表示失败。

外部函数在接收大的数组数据时更加有效.

`internal`这样声明的函数和状态变量只能通过内部访问。如在当前合约中调用，或继承的合约里调用。需要注意的是不能加前缀`this`，前缀`this`是表示通过外部方式访问。

**合约权限**：

|          | internal | external | public | private |
| :------- | -------- | -------- | ------ | ------- |
| 合约内部 | Y        | Y*       | Y      | Y       |
| 外部合约 | N        | Y        | Y      | N       |
| 继承合约 | Y        | Y        | Y      | N       |

`external*`：使用外部访问方法访问内部，`this.fuc()`

`public`：对其他contract自建访问器。

`is`=继承

ABI的不足：以太坊短地址攻击。

三种存储类型：值传递，引用传递memory/storage，**当引用类型作为函数参数时，它的类型默认为memory**，var声明一个变量时，这个变量的类型最终由赋给它值的类型决定。

函数默认为public类型，但是当我们的函数参数如果为storage类型时，函数的类型必须为internal或者private。当一个状态变量的权限为public类型时，它就会自动生成一个可供外部调用的get函数

软分叉可以理解为升级：微信1.0到微信2.0，具有**向后兼容性**，硬分叉属于完全分离不互通：微信和QQ

**mapping的真正作用**：mapping可以理解为：将地址作为一个索引，赋予地址代表的人更多的权利或者说是属性，例如：把一个address mapping到一个类上，那么就可以通过索引找到他真正的属性了。所以一个需要特殊功能和属性的合约（例如投票，或者其他需要集合复杂属性的类）一定需要mapping到一个结构体上（也就是我们说的属性集）*注：struct属性中不需要带有索引本身*。大多数address在合约中都充当索引。

引用类型有4种：字节数组`bytes`，字符串`string`，数组`array`，结构体`struct`。



