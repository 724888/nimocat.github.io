---
layout: post
title: 'Solidity语言整理'
subtitle: '收录区块链中常见概念及解答'
date: 2018-03-13
categories: 技术
cover: 'http://p3sactqby.bkt.clouddn.com/18-3-13/73161991.jpg'
tags: 区块链
---

# Solidity语言整理

## 资料

[Solidity中文文档](http://www.tryblockchain.org/Solidity%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html)

## 语言本身

**特性：**高级语言、类javascript+golang、支持ES6（不完全）的编译型语言

占空间大传引用，占空间小传值。大空间：字节数组、数组、字符串、结构体。

合约地址（uint160）是合约的指针，所以可以`mapping（address => String（匹配：建行合约#1030））`起到助记作用。

有`payable` 可以发value和使用`msg.value`，无`payable`不可以，所以重点在于**合约的函数具不具有处理转账的功能**，合约内功能的最小粒度为`function`。

ABI协议：contract => 二进制文件 => 二进制文件分割法则 => 以此定义接口。

<!--想法：竞技类区块链游戏（BRPG）开发，链上游戏，获得代币，良性循环，无充值游戏，让线上货币与线下货币进行交互，竞技激励模式（竞技游戏本身具有娱乐性，与养成类代币游戏严格区分，把游戏中的金币变成代币，玩家本身察觉不到，但是再在底层已经上链，游戏内货币具有价格波动，既具有投资价值也具有娱乐价值），甚至可以把contract概念变成套餐概念（一种玩家的投资）-->

不能对引用类型赋值：eg：

````go
uint[] y = x;
delete x;//OK 复写，类似磁盘强力删除(数据区域赋空白值)
delete y;//不行，y本身就是一个x的引用，因为数组类型在storage中，对他人引用赋值报错。
````

**数制转换**：低位转高位：OK；高位转低位：高位被截断

`selfdestruct(address recipt)`：跑路按钮，撕掉合约拿钱跑路。

需要注意的是，在合约的构造器中，不能使用`this`调用函数，因为当前合约还没有创建完成。

表达式执行顺序和java类似，不固定执行顺序，但保证调用栈是稳定的。

如果你通过消息调用一个函数，但在调用的过程中，并没有正确结束(gas不足，没有匹配到对应的函数，或他自己出现异常)。底层操作如`call`,`send`,`delegatecall`或`callcode`除外，它们不会抛出异常，但它们会通过返回`false`来表示失败。

外部函数在接收大的数组数据时更加有效.

`internal`这样声明的函数和状态变量只能通过内部访问。如在当前合约中调用，或继承的合约里调用。需要注意的是不能加前缀`this`，前缀`this`是表示通过外部方式访问。

**合约权限**：

|          | internal | external | public | private |
| :------- | -------- | -------- | ------ | ------- |
| 合约内部 | Y        | Y*       | Y      | Y       |
| 外部合约 | N        | Y        | Y      | N       |
| 继承合约 | Y        | Y        | Y      | N       |

`external*`：使用外部访问方法访问内部，`this.fuc()`

`public`：对其他contract自建访问器。

`is`=继承

ABI的不足：以太坊短地址攻击。

三种存储类型：值传递，引用传递memory/storage，**当引用类型作为函数参数时，它的类型默认为memory**，var声明一个变量时，这个变量的类型最终由赋给它值的类型决定。

函数默认为public类型，但是当我们的函数参数如果为storage类型时，函数的类型必须为internal或者private。当一个状态变量的权限为public类型时，它就会自动生成一个可供外部调用的get函数

软分叉可以理解为升级：微信1.0到微信2.0，具有**向后兼容性**，硬分叉属于完全分离不互通：微信和QQ

**mapping的真正作用**：mapping可以理解为：将地址作为一个索引，赋予地址代表的人更多的权利或者说是属性，例如：把一个address mapping到一个类上，那么就可以通过索引找到他真正的属性了。所以一个需要特殊功能和属性的合约（例如投票，或者其他需要集合复杂属性的类）一定需要mapping到一个结构体上（也就是我们说的属性集）*注：struct属性中不需要带有索引本身*。大多数address在合约中都充当索引。



